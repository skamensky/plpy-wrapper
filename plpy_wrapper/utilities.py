from typing import Tuple, Dict, Union
import plpy_wrapper
from plpy_wrapper import UtilityException, TypeException
from pathlib import Path


def list_to_sql_string(lst: Tuple[str]) -> str:
    """turns python lists into a string that can be put into a postgres tuple and serve as a list in postgres

    :param lst: a list of strings like ``['pg_catalog','information_schema']``

    :return: a string of items in SQL format ``"'pg_catalog','information_schema','hi'"``
    """
    return "'" + "','".join(lst) + "'"


def make_qualified_schema_name(schema_name: str, table_name: str) -> str:
    """produces a qualified schema name given a schema and table

    :param schema_name: the schema name
    :param table_name: the table name
    :return: a quoted dot separated qualified schema name
    """
    return '"{s}"."{t}"'.format(s=schema_name, t=table_name)


def check_nth_arg_is_of_type(n: int, type_to_check: type):
    """this decorator allows us to do some basic type checking

    :param n: the "nth" argument of the decorated function
    :param type_to_check: the type to ensure that the "nth" value is of
    :raises: :class:`plpy_wrapper.exceptions.TypeException`
    """

    def wrap(func):
        def inner(*args, **kwargs):
            if len(args) < n:
                raise TypeException("Not enough arguments")
            arg = args[n - 1]
            arg_type = type(arg)
            if arg_type is not type_to_check and not issubclass(
                arg_type, type_to_check
            ):
                raise TypeException(
                    f"argument number {n} must be of type {type_to_check}. Instead got {arg_type} "
                )
            func(*args, **kwargs)

        return inner

    return wrap


def create_plpython_triggers(
    plpy_wrapper: "plpy_wrapper.PLPYWrapper",
    schema: str,
    table_name: str,
    trigger_template_path: Union[str, Path, None] = Path(
        Path(__file__).parent, "trigger_process_template.txt"
    ),
    trigger_func_definition: Union[str, None] = "",
    trigger_func_name: Union[str, None] = "",
):
    """
    sets up triggers and the trigger function for a table.
    After running this function, triggers will now be routed to the custom function where you can run arbitrary python inside of the :class:`plpython.trigger.Trigger` methods.
    Should be executed from the DB like so::

        do $$
        import plpy_wrapper
        wrapper = plpy_wrapper.PLPYWrapper(globals())
        plpy_wrapper.utilities.create_plpython_triggers(wrapper,schema,table_name)
        $$ language plpython3u;

    :param trigger_func_name: if you provided a ``trigger_func_definition`` and your function name is different than the default function name generated by this function, provide the value for the function name
    :param trigger_func_definition: if provided, the value from ``trigger_template_path`` is ignored. The ``trigger_func_definition`` is sql that will be run before the CREATE trigger statements
    :param trigger_template_path: the path of the template that will be the base for trigger procedures. The file text must contain the following keyword parameters: ``schema``, ``table``, ``func_name`` otherwise unexpected behavior can be expected
    :param plpy_wrapper: instance of :class:`plpy_wrapper.plpy_wrapper.PLPYWrapper`
    :param schema: the schema name the table is located in
    :param table_name: the table to add the triggers and function to
    """

    # adding the underscore to avoid keyword collisions
    capital_camel_case = "_" + "".join(
        [word.lower().capitalize() for word in table_name.split("_")]
    )
    input_qualified_table_name = make_qualified_schema_name(schema, table_name)
    func_name = (
        trigger_func_name
        or '"{schema}".func_{schema}_{table}_trigger_controller'.format(
            schema=schema, table=table_name
        )
    )
    # we're keeping the procedure definition in a file since it's easier to visualize and maintain proper indentation that way
    func_definition = trigger_func_definition or open(
        trigger_template_path
    ).read().format(
        trigger_template_path,
        capital_camel_case=capital_camel_case,
        schema=schema,
        table=table_name,
        func_name=func_name,
    )

    trigger_commands = [
        line.format(
            table=table_name,
            schema_qualified_table_name=input_qualified_table_name,
            func_name=func_name,
            schema=schema,
        )
        for line in [
            "drop trigger if exists trig_{schema}_{table}_before on {schema_qualified_table_name};",
            "drop trigger if exists trig_{schema}_{table}_after on  {schema_qualified_table_name};",
            """create trigger trig_{schema}_{table}_before before update or insert or delete on {schema_qualified_table_name} for each row execute procedure {func_name}();""",
            """create trigger trig_{schema}_{table}_after after update or insert or delete on {schema_qualified_table_name} for each row execute procedure {func_name}();""",
        ]
    ]

    drop_commands = trigger_commands[:2]
    create_commands = trigger_commands[2:]

    all_qualified_table_names = [
        make_qualified_schema_name(table.schemaname, table.tablename)
        for table in get_all_tables(plpy_wrapper)
    ]
    if input_qualified_table_name not in all_qualified_table_names:
        raise UtilityException(
            f"The table and schema combination provided ({input_qualified_table_name}) does not exist."
        )

    # execute in this order since we know that the triggers (if they exist) have are dependent on the function, since we are
    # dropping the function in one of the commands, we must drop the triggers first
    sql_commands = drop_commands
    sql_commands.append(func_definition)
    sql_commands.extend(create_commands)
    [plpy_wrapper.execute(sql) for sql in sql_commands]


def get_all_tables(
    plpy_wrapper: "plpy_wrapper.PLPYWrapper",
    exclude_schemas: Tuple[str] = (),
    exclude_tables: Tuple[str] = (),
) -> "plpy_wrapper.ResultSet":
    """Queries postgres for all tables

    :param plpy_wrapper: PLPYWrapper instance
    :param exclude_schemas: schemas to exclude from the query
    :param exclude_tables: tables to exclude from the query
    :return:
    """
    return plpy_wrapper.execute(
        """  
        select tablename,schemaname from pg_catalog.pg_tables
        where schemaname not in ({schemas}) and tablename not in ({tables})
        """.format(
            schemas=list_to_sql_string(exclude_schemas),
            tables=list_to_sql_string(exclude_tables),
        )
    )


def execute_per_table(
    plpy_wrapper: "plpy_wrapper.PLPYWrapper",
    execute_definition: str,
    exclude_schemas: Tuple[str] = ("pg_catalog", "information_schema"),
    exclude_tables: Tuple[str] = (),
) -> Dict[str, "plpy_wrapper.ResultSet"]:
    """Run an SQL command per table.
    The execute_definition string must contain either ``{table}`` and/or ``{schema_qualified_table_name}`` as keyword parameters

    :param plpy_wrapper: PLPYWrapper instance
    :param execute_definition: the SQL to run per table
    :param exclude_schemas: schemas to exclude from the execution
    :param exclude_tables:  tables to exclude from the execution
    :return: a dictionary with the table's qualified schema name as the key and the ResultSet as the value
    """
    tbl_in = "{table}" in execute_definition
    schm_tb_in = "{schema_qualified_table_name}" in execute_definition
    if not tbl_in and not tbl_in:
        raise UtilityException(
            'Missing a required "{table}" or "{schema_qualified_table_name}" keyword parameter in the execute definition'
        )

    results = {}
    for table in get_all_tables(plpy_wrapper, exclude_schemas, exclude_tables):
        schema_qualified_table_name = make_qualified_schema_name(
            table.schemaname, table.tablename
        )
        table_name = table.tablename
        query = ""
        if tbl_in and schm_tb_in:
            query = execute_definition.format(
                schema_qualified_table_name=schema_qualified_table_name,
                table=table_name,
            )
        elif tbl_in:
            query = execute_definition.format(table=table_name)
        elif schm_tb_in:
            query = execute_definition.format(
                schema_qualified_table_name=schema_qualified_table_name
            )

        results[schema_qualified_table_name] = plpy_wrapper.execute(query)

    return results
